
// Copyright (c) 2010-2014 niXman (i dot nixman dog gmail dot com). All
// rights reserved.
//
// This file is part of YAS(https://github.com/niXman/yas) project.
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
//
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef _yas__information_hpp
#define _yas__information_hpp

#include <stddef.h>
#include <string.h>

#include <yas/detail/config/config.hpp>

#include <yas/detail/io/io_exceptions.hpp>
#include <yas/detail/io/endian_conv.hpp>

#include <yas/detail/type_traits/type_traits.hpp>
#include <yas/detail/type_traits/properties.hpp>

#include <yas/detail/preprocessor/preprocessor.hpp>

#include <yas/detail/version.hpp>

/***************************************************************************/

namespace yas {
namespace detail {

#pragma pack(push, 1)
union archive_header {
	archive_header()
		:as_char(0)
	{}
	archive_header(const std::int8_t c)
		:as_char(c)
	{}
	archive_header(const std::uint8_t v, const std::uint8_t t, const std::uint8_t b, const std::uint8_t e)
	{
		bits.version = v;
		bits.type = t;
		bits.bits = b;
		bits.endian = e;
	}

	struct {
		std::uint8_t version:3; // version     : 0 ... 7
		std::uint8_t type   :3; // archive type: binary, text, json
		std::uint8_t bits   :1; // bitnes      : 0 - 32 bit, 1 - 64 bit
		std::uint8_t endian :1; // endianness  : 0 - LE, 1 - BE
	} bits;
	std::int8_t as_char;
};
#pragma pack(pop)

static_assert(sizeof(archive_header)==sizeof(std::int8_t ), "ALIGNMENT ERROR");

/***************************************************************************/

namespace {

#ifdef YAS_DECORATE_HEADER_BYTES
static YAS_CONSTEXPR const char yas_id[] = {
	 'y' ^ YAS_PP_STRINGIZE(YAS_DECORATE_HEADER_BYTES)[0]
	,'a' ^ YAS_PP_STRINGIZE(YAS_DECORATE_HEADER_BYTES)[0]
	,'s' ^ YAS_PP_STRINGIZE(YAS_DECORATE_HEADER_BYTES)[0]
};
#else // !YAS_DECORATE_HEADER_BYTES
static YAS_CONSTEXPR const char yas_id[] = {'y', 'a', 's'};
#endif // YAS_DECORATE_HEADER_BYTES

static YAS_CONSTEXPR const char hex_alpha[] = {
	'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
};

} // ns

/***************************************************************************/

template<archive_type::type>
struct header_reader_writer;

template<>
struct header_reader_writer<archive_type::binary> {
	enum { header_size = 4 };

	template<typename IO>
	static void read(IO &io, yas::header_flag op, archive_header& header) {
		if ( op == yas::no_header ) return;

		char buf[header_size];
		std::streamsize rd = io.read(buf, header_size);
		if ( rd != header_size ) YAS_THROW_ARCHIVE_IS_EMPTY();
		if ( memcmp(buf, yas_id, sizeof(yas_id)) ) YAS_THROW_BAD_ARCHIVE_INFORMATION();
		header = *reinterpret_cast<archive_header*>(buf+sizeof(yas_id));
	}

	template<endian_t ET, typename IO>
	static void write(IO &io, yas::header_flag op, archive_type::type at) {
		if ( op == yas::no_header ) return;

		static const archive_header header(
			 (std::uint8_t)archive_version
			,(std::uint8_t)at
			,(std::uint8_t)YAS_PLATFORM_BITS_IS_64()
			,(std::uint8_t)(ET == as_host ? YAS_BIG_ENDIAN() : ET == big_endian)
		);
		static const std::int8_t buf[header_size] = {
			yas_id[0], yas_id[1], yas_id[2], header.as_char
		};

		YAS_THROW_ON_WRITE_ERROR(header_size, !=, io.write(&buf[0], header_size));
	}
};

/***************************************************************************/

template<>
struct header_reader_writer<archive_type::text> {
	enum {
		 header_size = 5
		,first_hex_pos = 3
		,second_hex_pos = 4
	};

	template<typename IO>
	static void read(IO &io, yas::header_flag op, archive_header& header) {
		if ( op == yas::no_header ) return;
		char buf[header_size];

		if ( io.read(buf, header_size) != header_size )
			YAS_THROW_ARCHIVE_IS_EMPTY();
		if ( memcmp(buf, yas_id, sizeof(yas_id)) )
			YAS_THROW_BAD_ARCHIVE_INFORMATION();

		const char* p = std::lower_bound(hex_alpha, hex_alpha+sizeof(hex_alpha), buf[first_hex_pos]);
		if (*p != buf[first_hex_pos]) YAS_THROW_BAD_BYTES_IN_HEADER();
		const char* q = std::lower_bound(hex_alpha, hex_alpha+sizeof(hex_alpha), buf[second_hex_pos]);
		if (*q != buf[second_hex_pos]) YAS_THROW_BAD_BYTES_IN_HEADER();

		header.as_char = (((p - hex_alpha) << 4) | (q - hex_alpha));
	}

	template<endian_t ET, typename IO>
	static void write(IO &io, yas::header_flag op, archive_type::type at) {
		if ( op == yas::no_header ) return;
		static const archive_header header(
			 (std::uint8_t)archive_version
			,(std::uint8_t)at
			,(std::uint8_t)YAS_PLATFORM_BITS_IS_64()
			,(std::uint8_t)(ET == as_host ? YAS_BIG_ENDIAN() : ET == big_endian)
		);

		static const char buf[header_size] = {
			 yas_id[0], yas_id[1], yas_id[2]
			,hex_alpha[(((std::uint8_t)header.as_char) >> 4) & 0xff]
			,hex_alpha[((std::uint8_t)header.as_char) & 15]
		};

		YAS_THROW_ON_WRITE_ERROR(header_size, !=, io.write(buf, header_size));
	}
};

/***************************************************************************/

template<>
struct header_reader_writer<archive_type::json> {
	enum {
		 header_size = 16
		,first_hex_pos = 11
		,second_hex_pos = 12
	};

	template<typename IO>
	static void read(IO &io, yas::header_flag op, archive_header& header) {
//		if ( op == yas::no_header ) return;
//		char buf[header_size];
//		static const char archive_id[11] = { '{','"','h','d','r','"',':','"',yas_id[0],yas_id[1],yas_id[2] };

//		if ( io.read(buf, header_size) != header_size )
//			YAS_THROW_ARCHIVE_IS_EMPTY();
//		if ( memcmp(buf, archive_id, sizeof(archive_id)) )
//			YAS_THROW_BAD_ARCHIVE_INFORMATION();

//		const char* p = std::lower_bound(hex_alpha, hex_alpha+sizeof(hex_alpha), buf[first_hex_pos]);
//		if (*p != buf[first_hex_pos]) YAS_THROW_BAD_BYTES_IN_HEADER();
//		const char* q = std::lower_bound(hex_alpha, hex_alpha+sizeof(hex_alpha), buf[second_hex_pos]);
//		if (*q != buf[second_hex_pos]) YAS_THROW_BAD_BYTES_IN_HEADER();

//		header.as_char = (((p - hex_alpha) << 4) | (q - hex_alpha));
	}

	template<endian_t ET, typename IO>
	static void write(IO &io, yas::header_flag op, archive_type::type at) {
//		if ( op == yas::no_header ) return;
//		static const archive_header header(
//			 (std::uint8_t)archive_version
//			,(std::uint8_t)at
//			,(std::uint8_t)YAS_PLATFORM_BITS_IS_64()
//			,(std::uint8_t)YAS_BIG_ENDIAN()
//		);

//		static const char buf[header_size] = {
//			 '{','"','h','d','r','"',':','"',yas_id[0],yas_id[1],yas_id[2]
//			,hex_alpha[(((std::uint8_t)header.as_char) >> 4) & 0xff]
//			,hex_alpha[((std::uint8_t)header.as_char) & 15]
//			,'"','}',','
//		};

//		YAS_THROW_ON_WRITE_ERROR(header_size, !=, io.write(buf, header_size));
	}
};

/***************************************************************************/

#define YAS_WRITE_ARCHIVE_INFORMATION_SPECIALIZATION_IMPL(unused, idx, seq) \
	template<typename IO, endian_t ET> \
	struct archive_information<YAS_PP_SEQ_ELEM(idx, seq), yas::direction::in, IO, ET> { \
		archive_information(IO &io, yas::header_flag op) \
			:io(io) \
			,header() \
		{ header_reader_writer<YAS_PP_SEQ_ELEM(idx, seq)>::read(io, op, header); } \
		\
		static YAS_CONSTEXPR std::uint32_t header_size() { return header_reader_writer<YAS_PP_SEQ_ELEM(idx, seq)>::header_size; } \
		static YAS_CONSTEXPR archive_type::type type() { return YAS_PP_SEQ_ELEM(idx, seq); } \
		std::uint32_t bits() const { \
			if ( !header.bits.version ) YAS_THROW_ARCHIVE_NO_HEADER(); \
			return (header.bits.bits ? 64 : 32); \
		} \
		bool is_big_endian() const { \
			if ( !header.bits.version ) YAS_THROW_ARCHIVE_NO_HEADER(); \
			return header.bits.endian; \
		} \
		bool is_little_endian() const { return !is_big_endian(); } \
		static YAS_CONSTEXPR endian_t host_endian() { return YAS_BIG_ENDIAN() ? big_endian : little_endian; } \
		\
		std::uint32_t version() const { \
			if ( !header.bits.version ) YAS_THROW_ARCHIVE_NO_HEADER(); \
			return header.bits.version; \
		} \
		\
		static YAS_CONSTEXPR yas::direction::type direction()	{ return yas::direction::in; } \
		\
		static YAS_CONSTEXPR bool is_readable()	{ return true; } \
		static YAS_CONSTEXPR bool is_writable() { return false; }\
		\
	private: \
		IO &io; \
		archive_header header; \
	}; \
	\
	template<typename IO, endian_t ET> \
	struct archive_information<YAS_PP_SEQ_ELEM(idx, seq), yas::direction::out, IO, ET> { \
		archive_information(IO &io, yas::header_flag op) \
			:io(io) \
		{ header_reader_writer<YAS_PP_SEQ_ELEM(idx, seq)>::write<ET>(io, op, YAS_PP_SEQ_ELEM(idx, seq)); } \
		\
		static YAS_CONSTEXPR std::uint32_t header_size() { return header_reader_writer<YAS_PP_SEQ_ELEM(idx, seq)>::header_size; } \
		static YAS_CONSTEXPR archive_type::type type() { return YAS_PP_SEQ_ELEM(idx, seq); } \
		static YAS_CONSTEXPR std::uint32_t bits() { return YAS_PLATFORM_BITS(); } \
		\
		static YAS_CONSTEXPR bool is_big_endian() { return ET == as_host ? YAS_BIG_ENDIAN() : ET == big_endian; } \
		static YAS_CONSTEXPR bool is_little_endian() { return ET == as_host ? YAS_LITTLE_ENDIAN() : ET == little_endian; } \
		static YAS_CONSTEXPR endian_t host_endian() { return YAS_BIG_ENDIAN() ? big_endian : little_endian; } \
		\
		static YAS_CONSTEXPR std::uint32_t version() { return archive_version; } \
		\
		static YAS_CONSTEXPR yas::direction::type direction() { return yas::direction::out; } \
		\
		static YAS_CONSTEXPR bool is_readable() { return false; } \
		static YAS_CONSTEXPR bool is_writable() { return true; } \
		\
	private: \
		IO &io; \
	};

#define YAS_WRITE_ARCHIVE_INFORMATION_SPECIALIZATIONS(seq) \
	YAS_PP_REPEAT( \
		YAS_PP_SEQ_SIZE(seq), \
		YAS_WRITE_ARCHIVE_INFORMATION_SPECIALIZATION_IMPL, \
		seq \
	)

/***************************************************************************/

template<
	 yas::archive_type::type
	,yas::direction::type
	,typename IO
	,endian_t ET
>
struct archive_information;

YAS_WRITE_ARCHIVE_INFORMATION_SPECIALIZATIONS(
	(archive_type::binary)
	(archive_type::text)
	(archive_type::json)
);

/***************************************************************************/

} // namespace detail
} // namespace yas

#endif // _yas__information_hpp
